## 문제
https://www.acmicpc.net/problem/15829

#### 해시함수
임의의 길이의 입력을 받아서 고정된 길이의 출력을 내보내는 함수  
대표적으로 자료의 저장과 탐색에 쓰인다.

해시 함수의 입력으로 들어올 수 있는 문자열의 종류는 무한하지만 출력 범위는 정해져있다.  
**비둘기집 원리**
n+1개의 물건을 n개의 상자에 넣을 때 적어도 어느 한 상자에는 두 개 이상의 물건이 들어 있다.  
이 원리에 의하면 서로 다른 문자열이더라도 동일한 해시 값을 가질 수 있다. 이를 **해시 충돌**이라고 한다.  
해시 충돌이 적을 수록 좋은 해시함수이다.

**목표**: 주어진 문자열의 해시 값 계산  
**출력**: 정수 해시 값  
**입력**: 영문소문자  

<br>

## 나의 답안
```python
r = 1
M = 1234567891
L = int(input())
s = input()
H = 0

for i in range(L):
    H = (H + ((ord(s[i]) - ord('a') + 1)) * r) % M
    r = (r * 31) % M

print(H)
```

## 접근 방법
모듈로 연산
- (a + b) mod n = {(a mod n) + (b mod n)} mod n
- (a - b) mod n = {(a mod n) - (b mod n)} mod n
- (a * b) mod n = {(a mod n) * (b mod n)} mod n

<br>
<br>

## 시도1: 50점
```python
for i in range(L):
    H += ((ord(s[i]) - ord('a') + 1) * (r**i) % M #r = 31
```

#### 내 코드 문제분석
Large: 1 ≤ L ≤ 50  
__(r**i) 연산이 문제!__
승수를 구하는 연산에서 계속하여 M을 나누어주자.

<br>

## 시도2: 50점
```python
for i in range(L):
    H += ((ord(s[i]) - ord('a') + 1)) * r % M # 초기 r = 1
    r = (r * 31) % M
```

#### 내 코드 문제분석
**연산자우선순위**
H += (expression) % M

이전에 연산한 H와 더하기 전에 모듈로 연산을 하고 있었다....
