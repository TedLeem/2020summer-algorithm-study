# 문제
지민이는 N개의 물병을 가지고 있다. 각 물병에는 물을 무한대로 부을 수 있다. 처음에 모든 물병에는 물이 1리터씩 들어있다. 지민이는 이 물병을 또 다른 장소로 옮기려고 한다. 지민이는 한 번에 K개의 물병을 옮길 수 있다. 하지만, 지민이는 물을 낭비하기는 싫고, 이동을 한 번보다 많이 하기는 싫다. 따라서, 지민이는 물병의 물을 적절히 재분배해서, __K개를 넘지 않는 비어있지 않은 물병__ 을 만들려고 한다.

물은 다음과 같이 재분배 한다.

먼저 같은 양의 물이 들어있는 물병 두 개를 고른다. 그 다음에 한 개의 물병에 다른 한 쪽에 있는 물을 모두 붓는다. 이 방법을 필요한 만큼 계속 한다.

이런 제약 때문에, N개로 K개를 넘지않는 비어있지 않은 물병을 만드는 것이 불가능할 수도 있다. 다행히도, 새로운 물병을 살 수 있다. 상점에서 사는 물병은 물이 1리터 들어있다.

예를 들어, N=3이고, K=1일 때를 보면, 물병 3개로 1개를 만드는 것이 불가능하다. 한 병을 또다른 병에 부으면, 2리터가 들어있는 물병 하나와, 1리터가 들어있는 물병 하나가 남는다. 만약 상점에서 한 개의 물병을 산다면, 2리터가 들어있는 물병 두 개를 만들 수 있고, 마지막으로 4리터가 들어있는 물병 한 개를 만들 수 있다.

# 입력
첫째 줄에 N과 K가 주어진다. N은 107보다 작거나 같은 자연수이고, K는 1,000보다 작거나 같은 자연수이다.

# 출력
첫째 줄에 상점에서 사야하는 물병의 최솟값을 출력한다. 만약 정답이 없을 경우에는 -1을 출력한다.


# 접근방법1
흠.. 
물의 재분배하는 방식을 살펴보면 같은양의 물만 서로 합칠 수 있는데 물의 양(리터)이 (홀+홀)or(짝+짝) = 짝이고 처음에는 모든 물병이 1리터 이므로 결국 하나의 물병은 2^n리터로 채워질 수 밖에 없다는 것을 알 수 있다.   
그래서 나는 N과 K 입력받았을 떄 N = 2^a + 2^b + 2^c..(총 k개) 형태로 표현을 하고 표현이 안되었을 떄(2^a + 2^b + 2^c+.. +홀수일 경우 )  
원하는 형식(2^a + 2^b + 2^c..(총 k개))을 만들기 위한 최소한의 리터를 찾는 방식을 생각해봤는데 일단 애초에 저런 형태로 표현을 어떻게하지? 생각이 안났다..  
N이 좀만 커져도 경우의수가 많아질 것 같은데... 알고리즘이 생각이 안난다..   

# 접근방법 2
그래서 애초에 처음부터 N을 2로 나눌 것이다.( 즉 합치는 것이다.)   
만약 2로 나누어지면 추가 물 필요없이 그냥 합치는 것이고 2로 나누어지지 않으면 추가 물이 필요하다.   
즉,    
나누어짐 => 고냥 합치면 됨
나누어지지않음 => 들고가야할 물병의 수가 늘어남 + 상점에서 물을 더 사야함 ( 이때 사야할 물의 리터수는 합쳐지지 않는 물병의 수의 리터와 동일하다 , 상점에서는 물을 1리터씩만 파니깐 4리터 물통과 합치려면 4개 물병을 더 사야하므로 고려해야함)   
그리고 들고가야할 물병의 수가 k보다 작거나 같으면 더 이상 상점에서 물을 살피요없이 그냥 그대로 들고가면 되므로 종료조건을 줌
하 이문제 내가 너무 어렵게 생각했다.. 
```python

def getCount(num) :
    cnt =0
    while(num >0) :
        if num%2 == 1 :
            cnt = cnt+1
        num //=2
    return cnt

N ,k = map(int,input().split())

result = N
while (True) :
    if getCount(result) <= k :
        break
    else:
        result +=1
print(result -N)
```
진짜 신기한게 뭐냐면 이 문제의 입력값을 원래 2의 n승의 조합으로 표현하려했으니깐 2진수로 나타내면 들고가야할 최소의 물병의 수와 리터를 바로 알 수 있따.
ex: 9 = 1001 => 8리터짜리 물병하나와 1리터짜리 물병하나 20 = 10100 => 16리터짜리 물병하나 + 4리터짜리 물병하나 신기방기
아 그리고 위 코드 시간초과가 난다..
hm..
