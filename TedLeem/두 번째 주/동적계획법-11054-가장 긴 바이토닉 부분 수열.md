# 가장 긴 바이토닉 수열

## 문제
수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

## 입력
첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)

## 출력
첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.

## 접근방법
이 문제가 동적계획법이라는 것을 생각 못하고 처음엔 스택을 이용해 백트래킹형식으로 풀으려했다가 잘 해결하지 못하였다. 
그 다음에 이 문제가 동적계획법에 속함을 알고 어떻게 해야할지 감이 온 것같았는데 풀지 못하였다.

### 동적계획법이란?
다른 블로그에 동적계획법 알고리즘에 대해 매우 자세히 설명한 블로그가 있어 해당 블로그의 사이트를 첨부하겠다.   
https://velog.io/@polynomeer/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming   

사이트에 들어가면 자세하게 나오겠지만 간단하게 개념과 적용사례에 대해 짚고 넘어가겠다.   
#### 동적계획법이란
동적계획법은 __큰 전체 문제를 작은 하위 문제로 쪼개어 하위 문제들의 답으로부터 큰 문제의 답을 알아내는 기법이다.__
#### 동적계획법의 조건
1. __겹치는 작은(부분)문제__
계속해서 같은 부분 문제가 여러번 재사용되거나 재귀 알고리즘을 통해 해결되는 문제를 가리킨다.

2. __최적 부분구조__
어떤 문제의 최적의 해결책이 그 부분 문제의 최적의 해결책으로부터 설계될 수 있는 경우를 말한다.   
이로써 문제의 정답을 작은 문제의 정답에서부터 구할 수 있다.
#### 메모제이션
동적계획법의 핵심은 __반드시 각 문제는 한 번 씩만 풀어야한다.__   
한 번씩 푼 문제의 정답을 메모하여 그 부분을 겹치는 문제에 재활용해야한다. 
### 동적계획법의 구현 방식
1. Top-Down : 큰 문제를 작은 문제로 쪼개는 (재귀)
2. Bottom-up : 작은 문제부터 차근차근 풀어나가는 (반복)

### 동적계획법과 분할정복
큰 문제를 작은 문제로 쪼개어 푸는 부분에서 두 알고리즘은 공통점이다.   
하지만 차이점은 __작은 문제가 중복이 일어나는지__ 이다.
동적계획법은 중복이 일어나는 문제들을 메모제이션했던 재활용하여 시간을 단축하는 반면, 분할정복은 그저 큰문제를 작은 문제로 쪼개어 푸는 것이다.
