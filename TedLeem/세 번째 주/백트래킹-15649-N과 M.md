# N과 M
## 문제
자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.

1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열
## 입력
첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)
## 출력
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.

수열은 사전 순으로 증가하는 순서로 출력해야 한다

## 수열이란
먼저 수열에 대한 정의부터 알아보자.   
수열은 수 또는 다른 대상의 __순서가 있는 나열이다__.   
__나열 순서를 생각__해야되는 점과 __중복이 허용__된다는 점이 집합과 다른점이다.

## 접근방법
사실 이 문제에 대하여 나는 왜 백트래킹이 적용되는지 잘 모르겠다. 나는 처음에 이 문제를 다중 반복문을 이용하려 접근하려했다.   
하지만 조합이면 몰라도 순열은 순서가 있으니 단순히 다중 반복문을 이용하여 해결할 수가 없다.   
사실 문제이해는 정말 쉬웠는데 코드로 어떻게 구현해야될지 전혀 감히 잡히지 않았고 백트래킹을 어떻게 적용해야 될지도 전혀 감히 잡히지 않았다.. 따라서 다른 해답을 참고하여 올려보겠다..   

### 해결방안 1
코드를 제시하여 설명하겠다.
나는 사실 내가 직접 디버깅하기 전까지도 이해가 잘 되지 않았다.   
보통 수열 문제를 접근할 때는 dfs와 백트래킹을 이용하는 것 같다.    
문득 생각이 들었는데, 이렇게 재귀 함수를 쓰는 문제같은 경우는 예시를 처음부터 어려운 경우를 고려하기보다는 2 2 형태와 같은 쉬운 경우부터 고려하는게 더 문제를 이해하고 해결하는데 도움이 되는 것 같다.


``` java
  import java.util.*;

public class Main {
	static int m,n; // N과 M을 입력받는다.
	static int list[],check[]; // 숫자의 방문여부를 체크 할 방문배열과 결과를 저장 할 배열을 선언
	
	static void dfs(int cnt) { // DFS메소드, 반복횟수를 인자로 받는다. 초기 0부터 시작
			
		if(cnt == m) { // 0부터 M번까지 반복했으면 하나의 처리가 완성
        			   // 개인적인 생각으로는 이부분이 백트래킹에 해당한다고 생각한다.
                       // M보다 큰 횟수는 고려하지 않고 배제한다.
			for(int i=0;i<m;i++) { // 현재 결과배열을 출력
				System.out.print(list[i]+" ");
			}
			System.out.println("");
			return; // DFS 종료 
		}
		
		for(int i =1;i<=n;i++) { // 수의 범위는 1부터 N까지이다.
			
			if(check[i]==1) continue; // 이미 방문한 배열이면 건너뛴다.
			check[i]=1; // 방문하지 않았다면, 방문처리 후
			list[cnt]=i; // 현재 반복횟수에 해당하는 배열에 i값을 넣는다.
			dfs(cnt+1); // 반복횟수를 증가시킨다.
			check[i]=0; // dfs가 종료 후에는 다시 방문여부를 0으로 초기화한다.
			
			
		}
		
		
	
	}
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);	
		
		n = sc.nextInt(); 
		m = sc.nextInt(); 
		
		check = new int[9]; // n과 m의 최대범위
		list = new int [9];
		dfs(0);
	}
	
}
```

## 참고사이트
https://fbtmdwhd33.tistory.com/36
