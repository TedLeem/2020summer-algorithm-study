# 문제
자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.

# 입력
첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.

# 출력
첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.

# 접근방법
일단 이 문제를 보고 처음에 든 생각은 pow를 써도 되는가?! 금데 쓰면 안될 것 같아서 일단 안쓰기로 했다
일단 입력값의 범위가 2,147,483,647 가 최대이다 이는 unsigned int가 나타낼 수 있는 최대값이다.    
즉 AXB를 하면 int의 범위를 넘어설 것이므로 long 을 사용해야 할 것을 인지했다. 그리고 이 문제는 거듭제곱수를 구하는 건데.. 결국 곱셈을 사용해야 할 것 같은데
왜 분할정복을 사용하면 계산의 속도가 증가되는지 이해가 안됬다.    
컴퓨터가 곱셈을 어떻게 연산을 하는지를 생각을 해봐야할 것 같았다.(컴퓨터는 실제로 덧셈을 이용해 곱셈을 처리한다.. 컴구에서 배움 from mr.paek)    
그래서 좀 무논리지만 나의 느낌상 컴퓨터는 10000 X 10000 의 계산이 10000000 X 10의 계산보다 빨리 수행해낼 것이라 생각했다.(안그러면 이런 문제가 있을..리가?) 

```java

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Multiply {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String str = br.readLine();
		StringTokenizer stk = new StringTokenizer(str);
		int N = Integer.parseInt(stk.nextToken());
		int M =Integer.parseInt(stk.nextToken());
		int divider = Integer.parseInt(stk.nextToken());
		
		long [] arr = new long[M];
		Arrays.fill(arr,N); // 배열의 모든 원소를 N으로 초기화하기
		long result = mulByDC(0, M, arr);
		result = result% divider;
		System.out.println();
	}
	
	public static long mulByDC(int left, int right, long[] arr) {
		if(left == right) {
			return arr[left];
		}
		else {
			return mulByDC(left, right/2, arr)* mulByDC(right/2+1, right, arr);
		}
	}
}
```
일단 스택오버플로우 에러가 났다.. 왜 함수가 계속 호출되는거지? 재귀함수 탈출조건을 명백히 적어놨는데...

# 해답...
ㅋㅋㅋㅋㅋㅋㅋ 나 WHYRANO............
