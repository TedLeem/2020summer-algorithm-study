# LCS
## 문제
LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.

## 입력
첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.

## 출력
첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.

## 접근방법1
두 수열의 공통 부분수열을 찾아야 하므로 이전 수열문제와 다르게 수열의 길이만 알면 안되고, 수열을 구성하는 원소도 구해야 한다고 생각했다.   
내가 생각한 알고리즘의 대략적인 순서는 다음과 같다.   
1. 입력된 수열 A,B가 있다고 하자. 이때, 수열의 길이를 1씩 줄이면서 해당 수열의 길이를 가질 수 있는 모든 부분수열을 구한다.   
2. 구한 부분수열을 B와 비교한다.   
문제는 1번을 어떻게 구현해야 될지 감이 안잡힌다는 점이였다.( 0과 1 조합으로 하려했는데 그것도 어떻게 구현해야될지도 모르겠고 dp를 사용하는 것 같지도 않는 느낌이였다..)   

## 접근방법2
입력받은 문자열이 ACAYKP, CAPCAK 라 해보자.    
그럼 다음과 같이 표 형태로 그려보면, 문제에 대한 접근이 쉬워진다.   
이떄, ACAYKP의 문자열을 기준으로 CAPCAK를 비교해보는 것이다.   
1. 초기    

||C|A|P|C|A|K
|---|---|---|---|---|---|---|
A|   |   |   |   |   |   |
C|   |   |   |   |   |   |
A|   |   |   |   |   |   |
Y|   |   |   |   |   |   |
K|   |   |   |   |   |   |
P|   |   |   |   |   |   |

2. 

||C|A|P|C|A|K
|---|---|---|---|---|---|---|
A|  x | 1  |   |   |   |   |
C|  x |  x |   |   |   |   |
A|  x |  x|   |   |   |   |
Y|  x | x  |   |   |   |   |
K|  x | x  |   |   |   |   |
P|  x |  x |   |   |   |   |       


여기서 [0][1]의 자리에 1이 채워지면, CAPCAK의 __A앞에는 고려할 필요가 없어진다.__ 따라서 그 다음 [1]부터는 [1][2]부터 고려하면 된다.      
이런 식으로 알고리즘을 작성한 것이다. 하지만 이는 ACAYKP기준으로 진행하므로 CAPCAK기준으로 해본 길이도 구한 후 최대값을 나타내줘야한다. 


### 코드
``` java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;

public class LCS {

	
	public static void main(String[] args) throws IOException {
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		String str1 = new String(br.readLine());
		String str2 = new String(br.readLine());
		
		int [] dp = new int[str2.length()];
		int length1 =0, length2=0;
		
		for(int i=0;i<str2.length();i++) {
			if(length1!=0) {
				for(int j = dp[length1-1] ; j< str1.length();j++) {
					if(str2.charAt(i) == str1.charAt(j)) {
						length1++;
						dp[length1-1] =j+1;
						break;	
					}
				}
			}else {
				for(int j = 0 ; j< str1.length();j++) {
					if(str2.charAt(i) == str1.charAt(j)) {
						length1++;
						dp[length1-1] =j+1;
						break;	
					}
				}
			}
		}
		
		//두번쨰 
		for(int i=0;i<str1.length();i++) {
			if(length2!=0) {
				for(int j = dp[length2-1] ; j< str2.length();j++) {
					if(str1.charAt(i) == str2.charAt(j)) {
						length2++;
						dp[length2-1] =j+1;
						break;	
					}
				}
			}else {
				for(int j = 0 ; j< str2.length();j++) {
					if(str1.charAt(i) == str2.charAt(j)) {
						length2++;
						dp[length2-1] =j+1;
						break;	
					}
				}
			}
		}

		System.out.println(Integer.max(length1, length2));
	}
	
}

```

처음에 하나의 기준의 경우만 생각해서 틀려서 둘다 모두 기준으로 고려한 경우 중 최대인 길이를 출력하도록 해봤는데 역시 틀렸다고 나온다.. 왜지?
## 접근방법 3



## LCS(Longest Common SubString), 최장 공통 부분 문자열 알고리즘

