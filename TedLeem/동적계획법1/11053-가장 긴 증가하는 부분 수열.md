# 가장 긴 증가하는 부분 수열
## 문제
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

## 입력
첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

## 출력
첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

## 정의
__부분수열__: 어떤 수열에서 일부 숫자를 지워서 만들 수 있는 새로운 수열을 가리킴   
__증가하는 부분 수열__ : 보통 Longest Increasing Subsequece(LIS)라고 말함   

## 접근방법1 

### 가정
배열 arr에 입력된 값들이 순서대로 저장된다고 하자.   
i번째 배열값을 포함하는 가장 긴 수열의 길이를 dp[i]에 저장된다고 하자.   

가장 중요한 알고리즘은 __1부터 i-1까지 비교해봄으로써 arr[i]가 크다면 dp[i] = dp[j]+1 을 한다.__  이다.  
```java
if(arr[i]>arr[j]) {
  dp[i]= dp[j]+1;
}
```

이 부분은 누구나 쉽게 생각할 수 있지만, 다음 조건을 생각해봐야한다.       
ex)   
|i|1|2|3|4 |5 |6 |
|---|---|---|---|---|---|---|
|arr|10|20|10|30|20|50|
|dp | 1 | 2 | 1 | 3 | ? |  |   

i가 5번째일때 경우를 생각해보자. arr[5]는 arr[1] 보다 크므로 dp[i]값은 2가 되는데, arr[3]도 10이므로 위의 알고리즘대로 하면 3이 된다.   
즉, 이런 경우를 배제해야 한다. 따라서 다음과 같은 조건도 추가된다. 
```java
if(arr[i]>arr[j] && dp[i]<=dp[j]) 
```
dp[i]값이 dp[j]값보다 작거나 같을 떄의 조건을 추가해줌으로써 위와 같은 상황을 배제할 수 있다.   
## 코드
``` java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class LIS1 {

	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		
		int arr[]= new int[N];
		int dp[] = new int[N];
		int max_length=1;
		
		StringTokenizer str = new StringTokenizer(br.readLine());
		
		for(int i=0; i<N;i++) {
			arr[i] = Integer.parseInt(str.nextToken());
		}
	
		for(int i=0;i<N;i++) {
			dp[i]=1;
			for(int j=0; j<i;j++) {
				if(arr[i]>arr[j] && dp[i]<=dp[j]) {
					dp[i]= dp[j]+1;
					max_length = Integer.max(dp[i], max_length);
				}
			}
		}
		
		System.out.println(max_length);
		
	}
}
```
시간복잡도: O(n^2)   

근데 이 문제 살짝 이상하게 이상하게 헷갈리면서도 쉬웠다.. 왜그럴까..

## 접근방법2
