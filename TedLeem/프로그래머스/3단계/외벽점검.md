# 문제
https://programmers.co.kr/learn/courses/30/lessons/60062

# 접근방법 1
이 문제는 그 완전탐색이다 모든 경우의 수를 다 고려해봐야하는 문제이다.   
말그대로 모든 경우의수를 고려한다음에 가장 적은 사람을 이용하여 외벽을 점검한 경우를 찾으면 되는데...    
일반 완전 탐색보다 좀 더 고려해야 할 경우가 더 있다.   

## 좀 난감했떤 부분
1. 벽의 모형이 원형이라는 점(선형X)  
범위에 대해 경우를 나눠 모듈러를 이용함(벽의 범위를 벗어날때를 경우에 따라 나눔)   
2. +, - 고려
둘 다 고려했을 떄 가장 점검을 많이하는 걸로 결정   
-> 10에 대해 +5를 하면 벽을 3개 점검하고 -5를 하면 2개 점검한다면, +5를 하는 것을 택함
3. 시간
일단 3중반복문을 써서 매우 매우 시간초과가 날 것 같았음   

## 내가 고려하지 못한 부분    
=> 어떤 외벽을 찾을 떄, 가장 많은 벽을 점검하는 dist원소를 찾아야하는데 이때, 같은 벽의 개수를 점검한다면, 가장 최소의 dist원소값으로 결정해야 한다.   

### 이 문제를 통해 느낀점
1. __최대한 추상화를 많이하자__   
알고 코드가 좀만 복잡해지고 변수도 많아지니깐 스파케티되서 진짜 오쥘라게 햇갈린다. 최소한의 기능은 함수를 통해 구현하고 메소드를 호출하여 사용하자.   
물론 함수를 작성하는데 시간이 걸리긴하지만 디버그할때 더 효율적이다. 어차피 오류는 반드시 나타는 것 같다.   
2. __경우의수를 이것저것 많이 생각하자__   
자꾸 문제의 테스트 코드를 해결하기 위한 어떻게 보면 편협한(?) 코드를 작성하게 되고 그 외의 경우는 고려하지 않는 것 같다. 최대한 모든 경우를 생각해 이를 대비해야하는데..  경우가 생각안나면.. 그건 ..noanswer..   


## 코드1(60점인가)
```python
import sys

def findNextIndex(check):
    for i in range(len(check)):
        if check[i] == False:
            return i
    return -1 
    # 좀더 빠르게 할 수 없나

def mainAlgo(n,temp,weak, dist, count, minN, check):
    for j in range(len(dist)-1 , -1, -1):                
        max = temp + dist[j]
        min = temp - dist[j]
        if max >n:
            max = max%n
            case1 = 1
        else: case1 = 2
        if min <0:
            min+= n
            case2 = 1
        else: case2 = 2

        cnt1 =0
        cnt2 =0
        # check배열 그대로 check1에 복사
        check1 = []
        check2 = []
        # s에 대해 
        for s in range(len(weak)) :
            if case1 == 1:
                # max값이 num를 넘어선경우
                if weak[s] >= temp or weak[s] <= max:
                    check1.append(s)
                    cnt1 +=1
            else:
                if weak[s] >= temp and weak[s] <= max:
                    check1.append(s)
                    cnt1 +=1
            if case2 == 1:
                # min값이 음수일경우
                if weak[s] <= temp or weak[s] >= min:
                    check2.append(s)    
                    cnt2 +=1           
            else:
                if weak[s] <= temp and weak[s] >= min:
                    check2.append(s)    
                    cnt2 +=1        

        distNum = max(cnt1,cnt2)        
        # 해당 dist가 할수있는 최대 칠할 수 있는 개수        
        if cnt1>= cnt2:                                
            for i in range(len(check1)):
                tempIndex = check1.pop()
                check[tempIndex] = True
        else:
            temp = findNextIndex(check2)
            for i in range(len(check2)):
                tempIndex = check2.pop()
                check[tempIndex] = True
                
        # 모든 벽을 다 점검했다라면
        if findNextIndex(check) == -1 :
            return count

        temp = findNextIndex(check) # 다음 검사시작 벽 번호를 찾아주는 함수
        temp = weak[temp]
        count +=1

def solution(n, weak, dist):
    
    answer = sys.maxsize
    dist.sort()
    print(dist)
    for i in range(len(weak)):

        temp = weak[i]        
        #  나누면 안될듯 + - 일지를 최대한의 개수의 true를 만드는 경우를 고르는 함수를 만들어야할듯
        count = 1
        minN = 9999
        check = [False] * len(weak)
        minN = mainAlgo(n,temp,weak,dist,count,minN,check)        
        if minN < answer:
            answer = minN
    return answer
```
=> 이 코드는 mainAlgo함수의 첫 부분에 해당 벽을 점검하는 dist원소를 찾을때, 최대 벽의 개수를 점검 and 최소 거리 이동 하는 dist원소를 찾는 코드를 추가해야한다.(완전탐색 또추가 dist부분만)   
# 해답을 본후
나는 아무생각없이 모든 경우를 다 고려하는 방법을 택했는데   
완전탐색을 사용해도 되는 이유가 ->dist의 길이가 8이하이기 떄문에 즉 친구가 별로없어서 가능하다.   
또 이문제는 원형이기 떄문에 + - 고려할 필요 없이 그냥 한 쪽 방향만? 생각하면 되는 것 같았다(차피중복인듯?증명늠 못하겠지만...feel이..)   
그리고 이 문제를 봤을 때 떠올라야 할 게 있다.   
바로
permutation이다.   
n명의 친구를 선택하여 나열할 수 있는 모든 경우의 수 (이떄, n은 1명부터 dist인원까지)   
n명의 친구를 선택하여 순서를 다르게하여 모두 나열한 후 해당 벽을 가장 최소한의 인원으로 점검하면 그 n명이 답이다.   
완전탐색 => (순열, 조합, 부분집합)
그래서 내가 고려하지뭇한 부분은 permutation한수를 통해 쉽게 해결할 수 있다..  

