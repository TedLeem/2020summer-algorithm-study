# 문제
어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.

예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.

문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

# 제한 조건
number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.
k는 1 이상 number의 자릿수 미만인 자연수입니다.

## 접근방법1 
큰 수를 구해야되니깐 처음에는 해당 숫자 문자열에서 가장 큰 숫자를 골라서 맨 앞에 위치해놓는 방법으로 생각을 해봤는데 숫자 문자열에서 있는 순서 그대로 큰 수를 구해야되서 해당 방법이 쉽지 않음을 느꼈다.

## 접근방법 2
재귀를 이용해 모든 경우의 수를 고려하는 방법을 생각해봤다. 문제는 재귀로 어떻게 구현해야 할지를 모르겠다는 점이다..
근데 해답을 찾아보니 이런 완전 탐색을 할 경우 최악의 경우 1,000,000 c 999,999 이므로 불가한다고 한다.

## 해답
이 문제의 가장 중요한 발상은 다음과 같다.   
만약 반환해야 할 숫자의 자리수가  n-k라고 하고 숫자 문자열의 길이가 n이라고 하자.   
__가장 큰 수를 반환해야하므로 가장 왼쪽에 위치해있는 수가 클수록 크다. 그러면 결국 숫자 문자열에서 맨 뒤의 n-k-1개의 숫자를 남겨놓고 앞에서 가장 큰 수를 고르고 그 숫자를 가장 왼쪽에 위치시킨다. 나머지는 이의 반복과정에 불가하다.__ 
### 기본조건
- 선택할 수 있는 범위는 선택한 숫자 오른편에 아직 선택해야할 갯수와 같거나 많은 숫자가 남아 있어야 한다.
### 생각의 흐름
1. 만약 리턴해야 하는 숫자의 자리수를 cnt라 해보자. (cnt는 선택해야하는 숫자의 개수라 하자.)   
2. 그러면 숫자문자열에서 뒤의 숫자 cnt-1개를 남겨놓고 앞에서 가장 큰 수를 찾는다.    
3. 그 범위를 left부터 right(number.length()-cnt)으로 설정한다. 여기서 left는 처음에는 0으로 초기화 하고 후에는 __큰 수의 다음 인덱스__ 나타낸다.    
이런식으로 cnt가 0보다 클 때까지 위의 1,2,3번의 과정을 반복한다.

```java
class Solution {
    public String solution(String number, int k) {
        StringBuilder sb = new StringBuilder();
	    
		int cnt = number.length() - k;
        int left = 0;
        int right = number.length() - cnt;
        int max = -1;
        int idx = 0;
        
        while(cnt > 0) {
        	 max = -1;
             for(int j = left ; j <= right ; ++j){
                 int num = number.charAt(j) - '0';
                 if(num > max){
                     idx = j;
                     max = num;
                 }
             }
             sb.append(number.charAt(idx));
             left = idx + 1;
             right = number.length() - --cnt;
        }

        return sb.toString();
    }
}
```

## 동적계획법과 그리디 알고리즘
Greedy Algorithm은 문제를 해결하는 과정에서 그 순간순간마다 최적이라고 생각되는 결정을 하는 방식으로 진행하여 최종 해답에 도달하는 문제 해결 방식이다. 여기서는 범위를 left부터 right까지를 설정함으로써 이 범위안에서 가장 큰 수를 구했으므로 해당 순간에 최적이라고 생각되는 결정을 하였다  그리디 알고리즘인 것 같다. 
